// This file was auto-generated by Fern from our API Definition.

package methodaws

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/Method-Security/methodaws/generated/go/core"
	time "time"
)

type Certificate struct {
	Arn       string `json:"arn" url:"arn"`
	IsDefault bool   `json:"isDefault" url:"isDefault"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Certificate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type unmarshaler Certificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Certificate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type IpAddressType string

const (
	IpAddressTypeIpv4                       IpAddressType = "IPV4"
	IpAddressTypeDualstack                  IpAddressType = "DUALSTACK"
	IpAddressTypeDualstackWithoutPublicIpv4 IpAddressType = "DUALSTACK_WITHOUT_PUBLIC_IPV4"
)

func NewIpAddressTypeFromString(s string) (IpAddressType, error) {
	switch s {
	case "IPV4":
		return IpAddressTypeIpv4, nil
	case "DUALSTACK":
		return IpAddressTypeDualstack, nil
	case "DUALSTACK_WITHOUT_PUBLIC_IPV4":
		return IpAddressTypeDualstackWithoutPublicIpv4, nil
	}
	var t IpAddressType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IpAddressType) Ptr() *IpAddressType {
	return &i
}

type Listener struct {
	Arn             *string        `json:"arn,omitempty" url:"arn,omitempty"`
	Protocol        Protocol       `json:"protocol" url:"protocol"`
	Port            int            `json:"port" url:"port"`
	Certificates    []*Certificate `json:"certificates,omitempty" url:"certificates,omitempty"`
	LoadBalancerArn string         `json:"loadBalancerArn" url:"loadBalancerArn"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Listener) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Listener) UnmarshalJSON(data []byte) error {
	type unmarshaler Listener
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Listener(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Listener) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoadBalancerReport struct {
	V2LoadBalancers []*LoadBalancerV2 `json:"v2LoadBalancers,omitempty" url:"v2LoadBalancers,omitempty"`
	V1LoadBalancers []*LoadBalancerV1 `json:"v1LoadBalancers,omitempty" url:"v1LoadBalancers,omitempty"`
	Errors          []string          `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerReport) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerReport) UnmarshalJSON(data []byte) error {
	type unmarshaler LoadBalancerReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoadBalancerReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerReport) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoadBalancerState string

const (
	LoadBalancerStateActive         LoadBalancerState = "ACTIVE"
	LoadBalancerStateProvisioning   LoadBalancerState = "PROVISIONING"
	LoadBalancerStateActiveImpaired LoadBalancerState = "ACTIVE_IMPAIRED"
	LoadBalancerStateFailed         LoadBalancerState = "FAILED"
)

func NewLoadBalancerStateFromString(s string) (LoadBalancerState, error) {
	switch s {
	case "ACTIVE":
		return LoadBalancerStateActive, nil
	case "PROVISIONING":
		return LoadBalancerStateProvisioning, nil
	case "ACTIVE_IMPAIRED":
		return LoadBalancerStateActiveImpaired, nil
	case "FAILED":
		return LoadBalancerStateFailed, nil
	}
	var t LoadBalancerState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoadBalancerState) Ptr() *LoadBalancerState {
	return &l
}

type LoadBalancerV1 struct {
	Name             string    `json:"name" url:"name"`
	CreatedTime      time.Time `json:"createdTime" url:"createdTime"`
	DnsName          string    `json:"dnsName" url:"dnsName"`
	SecurityGroupIds []string  `json:"securityGroupIds,omitempty" url:"securityGroupIds,omitempty"`
	VpcId            string    `json:"vpcId" url:"vpcId"`
	SubnetIds        []string  `json:"subnetIds,omitempty" url:"subnetIds,omitempty"`
	HostedZoneId     *string   `json:"hostedZoneId,omitempty" url:"hostedZoneId,omitempty"`
	Targets          []*Target `json:"targets,omitempty" url:"targets,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerV1) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerV1) UnmarshalJSON(data []byte) error {
	type embed LoadBalancerV1
	var unmarshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LoadBalancerV1(unmarshaler.embed)
	l.CreatedTime = unmarshaler.CreatedTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerV1) MarshalJSON() ([]byte, error) {
	type embed LoadBalancerV1
	var marshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed:       embed(*l),
		CreatedTime: core.NewDateTime(l.CreatedTime),
	}
	return json.Marshal(marshaler)
}

func (l *LoadBalancerV1) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// LoadBalancer represents a load balancer that distributes incoming network traffic across multiple servers.
// As defined by the AWS Go SDK (https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2@v1.33.1/types#LoadBalancer)
type LoadBalancerV2 struct {
	Arn              string             `json:"arn" url:"arn"`
	Name             string             `json:"name" url:"name"`
	CreatedTime      time.Time          `json:"createdTime" url:"createdTime"`
	DnsName          string             `json:"dnsName" url:"dnsName"`
	IpAddressType    IpAddressType      `json:"ipAddressType" url:"ipAddressType"`
	SecurityGroupIds []string           `json:"securityGroupIds,omitempty" url:"securityGroupIds,omitempty"`
	State            *LoadBalancerState `json:"state,omitempty" url:"state,omitempty"`
	VpcId            string             `json:"vpcId" url:"vpcId"`
	Listeners        []*Listener        `json:"listeners,omitempty" url:"listeners,omitempty"`
	SubnetIds        []string           `json:"subnetIds,omitempty" url:"subnetIds,omitempty"`
	HostedZoneId     *string            `json:"hostedZoneId,omitempty" url:"hostedZoneId,omitempty"`
	TargetGroups     []*TargetGroup     `json:"targetGroups,omitempty" url:"targetGroups,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerV2) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerV2) UnmarshalJSON(data []byte) error {
	type embed LoadBalancerV2
	var unmarshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LoadBalancerV2(unmarshaler.embed)
	l.CreatedTime = unmarshaler.CreatedTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerV2) MarshalJSON() ([]byte, error) {
	type embed LoadBalancerV2
	var marshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed:       embed(*l),
		CreatedTime: core.NewDateTime(l.CreatedTime),
	}
	return json.Marshal(marshaler)
}

func (l *LoadBalancerV2) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Protocol string

const (
	ProtocolHttp   Protocol = "HTTP"
	ProtocolHttps  Protocol = "HTTPS"
	ProtocolTcp    Protocol = "TCP"
	ProtocolTls    Protocol = "TLS"
	ProtocolUdp    Protocol = "UDP"
	ProtocolTcpUdp Protocol = "TCP_UDP"
	ProtocolGeneve Protocol = "GENEVE"
)

func NewProtocolFromString(s string) (Protocol, error) {
	switch s {
	case "HTTP":
		return ProtocolHttp, nil
	case "HTTPS":
		return ProtocolHttps, nil
	case "TCP":
		return ProtocolTcp, nil
	case "TLS":
		return ProtocolTls, nil
	case "UDP":
		return ProtocolUdp, nil
	case "TCP_UDP":
		return ProtocolTcpUdp, nil
	case "GENEVE":
		return ProtocolGeneve, nil
	}
	var t Protocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Protocol) Ptr() *Protocol {
	return &p
}

type Target struct {
	Id               string     `json:"id" url:"id"`
	Type             TargetType `json:"type" url:"type"`
	Port             int        `json:"port" url:"port"`
	AvailabilityZone *string    `json:"availabilityZone,omitempty" url:"availabilityZone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Target) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Target) UnmarshalJSON(data []byte) error {
	type unmarshaler Target
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Target(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Target) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetGroup struct {
	Arn             string                   `json:"arn" url:"arn"`
	Name            string                   `json:"name" url:"name"`
	IpAddressType   TargetGroupIpAddressType `json:"ipAddressType" url:"ipAddressType"`
	LoadBalancerArn string                   `json:"loadBalancerArn" url:"loadBalancerArn"`
	Port            int                      `json:"port" url:"port"`
	Protocol        Protocol                 `json:"protocol" url:"protocol"`
	VpcId           string                   `json:"vpcId" url:"vpcId"`
	Targets         []*Target                `json:"targets,omitempty" url:"targets,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TargetGroup) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TargetGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetGroup) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetGroupIpAddressType string

const (
	TargetGroupIpAddressTypeIpv4 TargetGroupIpAddressType = "IPV4"
	TargetGroupIpAddressTypeIpv6 TargetGroupIpAddressType = "IPV6"
)

func NewTargetGroupIpAddressTypeFromString(s string) (TargetGroupIpAddressType, error) {
	switch s {
	case "IPV4":
		return TargetGroupIpAddressTypeIpv4, nil
	case "IPV6":
		return TargetGroupIpAddressTypeIpv6, nil
	}
	var t TargetGroupIpAddressType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TargetGroupIpAddressType) Ptr() *TargetGroupIpAddressType {
	return &t
}

type TargetType string

const (
	TargetTypeInstance TargetType = "INSTANCE"
	TargetTypeIp       TargetType = "IP"
	TargetTypeLambda   TargetType = "LAMBDA"
)

func NewTargetTypeFromString(s string) (TargetType, error) {
	switch s {
	case "INSTANCE":
		return TargetTypeInstance, nil
	case "IP":
		return TargetTypeIp, nil
	case "LAMBDA":
		return TargetTypeLambda, nil
	}
	var t TargetType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TargetType) Ptr() *TargetType {
	return &t
}
