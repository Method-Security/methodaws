// This file was auto-generated by Fern from our API Definition.

package methodaws

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/Method-Security/methodaws/generated/go/core"
	time "time"
)

type CredentialInfo struct {
	Url        string     `json:"url" url:"url"`
	Token      string     `json:"token" url:"token"`
	CaCert     *string    `json:"caCert,omitempty" url:"caCert,omitempty"`
	Expiration *time.Time `json:"expiration,omitempty" url:"expiration,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialInfo) UnmarshalJSON(data []byte) error {
	type embed CredentialInfo
	var unmarshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = CredentialInfo(unmarshaler.embed)
	c.Expiration = unmarshaler.Expiration.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialInfo) MarshalJSON() ([]byte, error) {
	type embed CredentialInfo
	var marshaler = struct {
		embed
		Expiration *core.DateTime `json:"expiration,omitempty"`
	}{
		embed:      embed(*c),
		Expiration: core.NewOptionalDateTime(c.Expiration),
	}
	return json.Marshal(marshaler)
}

func (c *CredentialInfo) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CredentialReport struct {
	AccountId   string          `json:"accountId" url:"accountId"`
	ClusterName string          `json:"clusterName" url:"clusterName"`
	Credential  *CredentialInfo `json:"credential,omitempty" url:"credential,omitempty"`
	Errors      []string        `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *CredentialReport) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CredentialReport) UnmarshalJSON(data []byte) error {
	type unmarshaler CredentialReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CredentialReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CredentialReport) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Certificate struct {
	Arn       string `json:"arn" url:"arn"`
	IsDefault bool   `json:"isDefault" url:"isDefault"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (c *Certificate) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Certificate) UnmarshalJSON(data []byte) error {
	type unmarshaler Certificate
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = Certificate(value)

	extraProperties, err := core.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Certificate) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type IpAddressType string

const (
	IpAddressTypeIpv4                       IpAddressType = "IPV4"
	IpAddressTypeDualstack                  IpAddressType = "DUALSTACK"
	IpAddressTypeDualstackWithoutPublicIpv4 IpAddressType = "DUALSTACK_WITHOUT_PUBLIC_IPV4"
)

func NewIpAddressTypeFromString(s string) (IpAddressType, error) {
	switch s {
	case "IPV4":
		return IpAddressTypeIpv4, nil
	case "DUALSTACK":
		return IpAddressTypeDualstack, nil
	case "DUALSTACK_WITHOUT_PUBLIC_IPV4":
		return IpAddressTypeDualstackWithoutPublicIpv4, nil
	}
	var t IpAddressType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IpAddressType) Ptr() *IpAddressType {
	return &i
}

type Listener struct {
	Arn             *string        `json:"arn,omitempty" url:"arn,omitempty"`
	Protocol        *Protocol      `json:"protocol,omitempty" url:"protocol,omitempty"`
	Port            int            `json:"port" url:"port"`
	Certificates    []*Certificate `json:"certificates,omitempty" url:"certificates,omitempty"`
	LoadBalancerArn *string        `json:"loadBalancerArn,omitempty" url:"loadBalancerArn,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Listener) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Listener) UnmarshalJSON(data []byte) error {
	type unmarshaler Listener
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Listener(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Listener) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoadBalancerReport struct {
	AccountId       string            `json:"accountId" url:"accountId"`
	V2LoadBalancers []*LoadBalancerV2 `json:"v2LoadBalancers,omitempty" url:"v2LoadBalancers,omitempty"`
	V1LoadBalancers []*LoadBalancerV1 `json:"v1LoadBalancers,omitempty" url:"v1LoadBalancers,omitempty"`
	Errors          []string          `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerReport) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerReport) UnmarshalJSON(data []byte) error {
	type unmarshaler LoadBalancerReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LoadBalancerReport(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerReport) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LoadBalancerState string

const (
	LoadBalancerStateActive         LoadBalancerState = "ACTIVE"
	LoadBalancerStateProvisioning   LoadBalancerState = "PROVISIONING"
	LoadBalancerStateActiveImpaired LoadBalancerState = "ACTIVE_IMPAIRED"
	LoadBalancerStateFailed         LoadBalancerState = "FAILED"
)

func NewLoadBalancerStateFromString(s string) (LoadBalancerState, error) {
	switch s {
	case "ACTIVE":
		return LoadBalancerStateActive, nil
	case "PROVISIONING":
		return LoadBalancerStateProvisioning, nil
	case "ACTIVE_IMPAIRED":
		return LoadBalancerStateActiveImpaired, nil
	case "FAILED":
		return LoadBalancerStateFailed, nil
	}
	var t LoadBalancerState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LoadBalancerState) Ptr() *LoadBalancerState {
	return &l
}

type LoadBalancerV1 struct {
	Name             string      `json:"name" url:"name"`
	CreatedTime      time.Time   `json:"createdTime" url:"createdTime"`
	DnsName          string      `json:"dnsName" url:"dnsName"`
	SecurityGroupIds []string    `json:"securityGroupIds,omitempty" url:"securityGroupIds,omitempty"`
	VpcId            string      `json:"vpcId" url:"vpcId"`
	SubnetIds        []string    `json:"subnetIds,omitempty" url:"subnetIds,omitempty"`
	HostedZoneId     *string     `json:"hostedZoneId,omitempty" url:"hostedZoneId,omitempty"`
	Targets          []*Target   `json:"targets,omitempty" url:"targets,omitempty"`
	Listeners        []*Listener `json:"listeners,omitempty" url:"listeners,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerV1) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerV1) UnmarshalJSON(data []byte) error {
	type embed LoadBalancerV1
	var unmarshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LoadBalancerV1(unmarshaler.embed)
	l.CreatedTime = unmarshaler.CreatedTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerV1) MarshalJSON() ([]byte, error) {
	type embed LoadBalancerV1
	var marshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed:       embed(*l),
		CreatedTime: core.NewDateTime(l.CreatedTime),
	}
	return json.Marshal(marshaler)
}

func (l *LoadBalancerV1) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// LoadBalancer represents a load balancer that distributes incoming network traffic across multiple servers.
// As defined by the AWS Go SDK (https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/elasticloadbalancingv2@v1.33.1/types#LoadBalancer)
type LoadBalancerV2 struct {
	Arn              string             `json:"arn" url:"arn"`
	Name             string             `json:"name" url:"name"`
	CreatedTime      time.Time          `json:"createdTime" url:"createdTime"`
	DnsName          string             `json:"dnsName" url:"dnsName"`
	IpAddressType    IpAddressType      `json:"ipAddressType" url:"ipAddressType"`
	SecurityGroupIds []string           `json:"securityGroupIds,omitempty" url:"securityGroupIds,omitempty"`
	State            *LoadBalancerState `json:"state,omitempty" url:"state,omitempty"`
	VpcId            string             `json:"vpcId" url:"vpcId"`
	Listeners        []*Listener        `json:"listeners,omitempty" url:"listeners,omitempty"`
	SubnetIds        []string           `json:"subnetIds,omitempty" url:"subnetIds,omitempty"`
	HostedZoneId     *string            `json:"hostedZoneId,omitempty" url:"hostedZoneId,omitempty"`
	TargetGroups     []*TargetGroup     `json:"targetGroups,omitempty" url:"targetGroups,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *LoadBalancerV2) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LoadBalancerV2) UnmarshalJSON(data []byte) error {
	type embed LoadBalancerV2
	var unmarshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed: embed(*l),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*l = LoadBalancerV2(unmarshaler.embed)
	l.CreatedTime = unmarshaler.CreatedTime.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LoadBalancerV2) MarshalJSON() ([]byte, error) {
	type embed LoadBalancerV2
	var marshaler = struct {
		embed
		CreatedTime *core.DateTime `json:"createdTime"`
	}{
		embed:       embed(*l),
		CreatedTime: core.NewDateTime(l.CreatedTime),
	}
	return json.Marshal(marshaler)
}

func (l *LoadBalancerV2) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Protocol string

const (
	ProtocolHttp   Protocol = "HTTP"
	ProtocolHttps  Protocol = "HTTPS"
	ProtocolTcp    Protocol = "TCP"
	ProtocolTls    Protocol = "TLS"
	ProtocolUdp    Protocol = "UDP"
	ProtocolTcpUdp Protocol = "TCP_UDP"
	ProtocolGeneve Protocol = "GENEVE"
)

func NewProtocolFromString(s string) (Protocol, error) {
	switch s {
	case "HTTP":
		return ProtocolHttp, nil
	case "HTTPS":
		return ProtocolHttps, nil
	case "TCP":
		return ProtocolTcp, nil
	case "TLS":
		return ProtocolTls, nil
	case "UDP":
		return ProtocolUdp, nil
	case "TCP_UDP":
		return ProtocolTcpUdp, nil
	case "GENEVE":
		return ProtocolGeneve, nil
	}
	var t Protocol
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p Protocol) Ptr() *Protocol {
	return &p
}

type Target struct {
	Id               string     `json:"id" url:"id"`
	Type             TargetType `json:"type" url:"type"`
	Port             int        `json:"port" url:"port"`
	AvailabilityZone *string    `json:"availabilityZone,omitempty" url:"availabilityZone,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *Target) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *Target) UnmarshalJSON(data []byte) error {
	type unmarshaler Target
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Target(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Target) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetGroup struct {
	Arn             string                   `json:"arn" url:"arn"`
	Name            string                   `json:"name" url:"name"`
	IpAddressType   TargetGroupIpAddressType `json:"ipAddressType" url:"ipAddressType"`
	LoadBalancerArn string                   `json:"loadBalancerArn" url:"loadBalancerArn"`
	Port            int                      `json:"port" url:"port"`
	Protocol        *Protocol                `json:"protocol,omitempty" url:"protocol,omitempty"`
	VpcId           string                   `json:"vpcId" url:"vpcId"`
	Targets         []*Target                `json:"targets,omitempty" url:"targets,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (t *TargetGroup) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TargetGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler TargetGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TargetGroup(value)

	extraProperties, err := core.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties

	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TargetGroup) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TargetGroupIpAddressType string

const (
	TargetGroupIpAddressTypeIpv4 TargetGroupIpAddressType = "IPV4"
	TargetGroupIpAddressTypeIpv6 TargetGroupIpAddressType = "IPV6"
)

func NewTargetGroupIpAddressTypeFromString(s string) (TargetGroupIpAddressType, error) {
	switch s {
	case "IPV4":
		return TargetGroupIpAddressTypeIpv4, nil
	case "IPV6":
		return TargetGroupIpAddressTypeIpv6, nil
	}
	var t TargetGroupIpAddressType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TargetGroupIpAddressType) Ptr() *TargetGroupIpAddressType {
	return &t
}

type TargetType string

const (
	TargetTypeInstance TargetType = "INSTANCE"
	TargetTypeIp       TargetType = "IP"
	TargetTypeLambda   TargetType = "LAMBDA"
)

func NewTargetTypeFromString(s string) (TargetType, error) {
	switch s {
	case "INSTANCE":
		return TargetTypeInstance, nil
	case "IP":
		return TargetTypeIp, nil
	case "LAMBDA":
		return TargetTypeLambda, nil
	}
	var t TargetType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TargetType) Ptr() *TargetType {
	return &t
}

type Bucket struct {
	Name               string                            `json:"name" url:"name"`
	Arn                string                            `json:"arn" url:"arn"`
	Url                string                            `json:"url" url:"url"`
	CreationDate       time.Time                         `json:"creationDate" url:"creationDate"`
	OwnerId            string                            `json:"ownerID" url:"ownerID"`
	OwnerName          string                            `json:"ownerName" url:"ownerName"`
	PublicAccessConfig *S3PublicAccessBlockConfiguration `json:"publicAccessConfig,omitempty" url:"publicAccessConfig,omitempty"`
	Policy             *string                           `json:"policy,omitempty" url:"policy,omitempty"`
	BucketVersioning   *BucketVersioningStatus           `json:"bucketVersioning,omitempty" url:"bucketVersioning,omitempty"`
	MfaDelete          *S3MfaDeleteStatus                `json:"mfaDelete,omitempty" url:"mfaDelete,omitempty"`
	EncryptionRules    []*EncryptionRule                 `json:"encryptionRules,omitempty" url:"encryptionRules,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (b *Bucket) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *Bucket) UnmarshalJSON(data []byte) error {
	type embed Bucket
	var unmarshaler = struct {
		embed
		CreationDate *core.DateTime `json:"creationDate"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = Bucket(unmarshaler.embed)
	b.CreationDate = unmarshaler.CreationDate.Time()

	extraProperties, err := core.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties

	b._rawJSON = json.RawMessage(data)
	return nil
}

func (b *Bucket) MarshalJSON() ([]byte, error) {
	type embed Bucket
	var marshaler = struct {
		embed
		CreationDate *core.DateTime `json:"creationDate"`
	}{
		embed:        embed(*b),
		CreationDate: core.NewDateTime(b.CreationDate),
	}
	return json.Marshal(marshaler)
}

func (b *Bucket) String() string {
	if len(b._rawJSON) > 0 {
		if value, err := core.StringifyJSON(b._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BucketVersioningStatus string

const (
	BucketVersioningStatusEnabled   BucketVersioningStatus = "Enabled"
	BucketVersioningStatusSuspended BucketVersioningStatus = "Suspended"
)

func NewBucketVersioningStatusFromString(s string) (BucketVersioningStatus, error) {
	switch s {
	case "Enabled":
		return BucketVersioningStatusEnabled, nil
	case "Suspended":
		return BucketVersioningStatusSuspended, nil
	}
	var t BucketVersioningStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BucketVersioningStatus) Ptr() *BucketVersioningStatus {
	return &b
}

type EncryptionRule struct {
	SseAlgorithm   *S3ServerSideEncryption `json:"sseAlgorithm,omitempty" url:"sseAlgorithm,omitempty"`
	KmsMasterKeyId *string                 `json:"kmsMasterKeyID,omitempty" url:"kmsMasterKeyID,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *EncryptionRule) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EncryptionRule) UnmarshalJSON(data []byte) error {
	type unmarshaler EncryptionRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EncryptionRule(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EncryptionRule) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalBucket struct {
	Url                   string             `json:"url" url:"url"`
	Region                string             `json:"region" url:"region"`
	DirectoryContents     []*S3ObjectDetails `json:"directoryContents,omitempty" url:"directoryContents,omitempty"`
	AllowDirectoryListing bool               `json:"allowDirectoryListing" url:"allowDirectoryListing"`
	AllowAnonymousRead    bool               `json:"allowAnonymousRead" url:"allowAnonymousRead"`
	Policy                *string            `json:"policy,omitempty" url:"policy,omitempty"`
	Acls                  []*S3BucketAcl     `json:"acls,omitempty" url:"acls,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalBucket) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalBucket) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalBucket
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalBucket(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalBucket) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ExternalS3Report struct {
	ExternalBuckets []*ExternalBucket `json:"externalBuckets,omitempty" url:"externalBuckets,omitempty"`
	Errors          []string          `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ExternalS3Report) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ExternalS3Report) UnmarshalJSON(data []byte) error {
	type unmarshaler ExternalS3Report
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ExternalS3Report(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ExternalS3Report) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type S3BucketAcl struct {
	GranteeUri string `json:"granteeURI" url:"granteeURI"`
	Permission string `json:"permission" url:"permission"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *S3BucketAcl) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3BucketAcl) UnmarshalJSON(data []byte) error {
	type unmarshaler S3BucketAcl
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = S3BucketAcl(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3BucketAcl) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type S3MfaDeleteStatus string

const (
	S3MfaDeleteStatusEnabled  S3MfaDeleteStatus = "Enabled"
	S3MfaDeleteStatusDisabled S3MfaDeleteStatus = "Disabled"
)

func NewS3MfaDeleteStatusFromString(s string) (S3MfaDeleteStatus, error) {
	switch s {
	case "Enabled":
		return S3MfaDeleteStatusEnabled, nil
	case "Disabled":
		return S3MfaDeleteStatusDisabled, nil
	}
	var t S3MfaDeleteStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s S3MfaDeleteStatus) Ptr() *S3MfaDeleteStatus {
	return &s
}

type S3ObjectDetails struct {
	Key          string     `json:"key" url:"key"`
	LastModified *time.Time `json:"lastModified,omitempty" url:"lastModified,omitempty"`
	Size         *int       `json:"size,omitempty" url:"size,omitempty"`
	OwnerId      *string    `json:"ownerID,omitempty" url:"ownerID,omitempty"`
	OwnerName    *string    `json:"ownerName,omitempty" url:"ownerName,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *S3ObjectDetails) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3ObjectDetails) UnmarshalJSON(data []byte) error {
	type embed S3ObjectDetails
	var unmarshaler = struct {
		embed
		LastModified *core.DateTime `json:"lastModified,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = S3ObjectDetails(unmarshaler.embed)
	s.LastModified = unmarshaler.LastModified.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3ObjectDetails) MarshalJSON() ([]byte, error) {
	type embed S3ObjectDetails
	var marshaler = struct {
		embed
		LastModified *core.DateTime `json:"lastModified,omitempty"`
	}{
		embed:        embed(*s),
		LastModified: core.NewOptionalDateTime(s.LastModified),
	}
	return json.Marshal(marshaler)
}

func (s *S3ObjectDetails) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type S3PublicAccessBlockConfiguration struct {
	BlockPublicAcls       bool `json:"blockPublicAcls" url:"blockPublicAcls"`
	IgnorePublicAcls      bool `json:"ignorePublicAcls" url:"ignorePublicAcls"`
	BlockPublicPolicy     bool `json:"blockPublicPolicy" url:"blockPublicPolicy"`
	RestrictPublicBuckets bool `json:"restrictPublicBuckets" url:"restrictPublicBuckets"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *S3PublicAccessBlockConfiguration) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3PublicAccessBlockConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler S3PublicAccessBlockConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = S3PublicAccessBlockConfiguration(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3PublicAccessBlockConfiguration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type S3Report struct {
	AccountId string    `json:"accountId" url:"accountId"`
	S3Buckets []*Bucket `json:"s3Buckets,omitempty" url:"s3Buckets,omitempty"`
	Errors    []string  `json:"errors,omitempty" url:"errors,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (s *S3Report) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *S3Report) UnmarshalJSON(data []byte) error {
	type unmarshaler S3Report
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = S3Report(value)

	extraProperties, err := core.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties

	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *S3Report) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type S3ServerSideEncryption string

const (
	S3ServerSideEncryptionAes256     S3ServerSideEncryption = "AES256"
	S3ServerSideEncryptionAwskms     S3ServerSideEncryption = "aws:kms"
	S3ServerSideEncryptionAwskmsdsse S3ServerSideEncryption = "aws:kms:dsse"
)

func NewS3ServerSideEncryptionFromString(s string) (S3ServerSideEncryption, error) {
	switch s {
	case "AES256":
		return S3ServerSideEncryptionAes256, nil
	case "aws:kms":
		return S3ServerSideEncryptionAwskms, nil
	case "aws:kms:dsse":
		return S3ServerSideEncryptionAwskmsdsse, nil
	}
	var t S3ServerSideEncryption
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s S3ServerSideEncryption) Ptr() *S3ServerSideEncryption {
	return &s
}
